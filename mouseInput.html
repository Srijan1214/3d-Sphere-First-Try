<!--
/**
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
-->
<!doctype html>

<html>

<head>
    <meta charset="utf-8">
    <title>02: Drawing a Square - WebGPU Life</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }
</style>
</head>

<body>
    <canvas></canvas>
    <script type="module">
        const canvas = document.querySelector("canvas");

        // WebGPU device initialization
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error("No appropriate GPUAdapter found.");
        }

        const device = await adapter.requestDevice();

        // Canvas configuration
        const context = canvas.getContext("webgpu");
        const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

        function resizeCanvasAndConfigure() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            context.configure({
                device: device,
                format: canvasFormat,
                alphaMode: "opaque"
            });
        }
        window.addEventListener("resize", resizeCanvasAndConfigure);
        resizeCanvasAndConfigure();

        // Create the shader that will render the cells.
        const cellShaderModule = device.createShaderModule({
            label: "Cell shader",
            code: `
            struct VertexOutput {
                @builtin(position) position: vec4f,
                @location(0) pos: vec2f,
            };
            
            @vertex
            fn vertexMain(@location(0) position: vec2f) -> VertexOutput {
                var out: VertexOutput;
                out.position = vec4f(position, 0, 1);
                out.pos = position;
                return out;
            }
            
            @fragment
            fn fragmentMain(@location(0) pos: vec2f) -> @location(0) vec4f {
                return vec4f(abs(pos.x), abs(pos.y), abs(pos.x), 1);
            }
            `
        });

        const vertexBufferLayout = {
            arrayStride: 8,
            attributes: [{
                format: "float32x2",
                offset: 0,
                shaderLocation: 0, // Position. Matches @location(0) in the @vertex shader.
            }],
        };

        // Create a pipeline that renders the cell.
        const cellPipeline = device.createRenderPipeline({
            label: "Cell pipeline",
            layout: "auto",
            vertex: {
                module: cellShaderModule,
                entryPoint: "vertexMain",
                buffers: [vertexBufferLayout]
            },
            fragment: {
                module: cellShaderModule,
                entryPoint: "fragmentMain",
                targets: [{
                    format: canvasFormat
                }]
            }
        });

        const vertices = new Float32Array([
            -1, -1,  // bottom left
            1, -1,  // bottom right
            -1, 1,  // top left
            -1, 1,  // top left
            1, -1,  // bottom right
            1, 1,  // top right
        ])
        const vertexBuffer = device.createBuffer({
            label: "Cell vertices",
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        function render() {
            // Clear the canvas with a render pass
            const encoder = device.createCommandEncoder();

            const pass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: "clear",
                    storeOp: "store",
                }]
            });

            // Draw the square.
            pass.setPipeline(cellPipeline);
            pass.setVertexBuffer(0, vertexBuffer);
            pass.draw(vertices.length / 2);

            pass.end();

            device.queue.submit([encoder.finish()]);
        }

        function animate() {
            device.queue.writeBuffer(vertexBuffer, 0, vertices);

            render();
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

    </script>
</body>

</html>